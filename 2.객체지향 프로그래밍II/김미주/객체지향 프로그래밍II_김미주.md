## 상속
### 상속의 정의와 장점
- 상속:기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 장점: 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있어서 코드의 추가 및 변경이 매우 용이하다
- 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
- 방법: 새로 작성하고자 하는 ㅡㄹ래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 쓴다
```
class Child extends Parent{
    // ...
}
```

- 조상클래스: 부모클래스, 상위클래스, 기반클래스
- 자손클래스: 자식클래스, 하위클래스, 파생된클래스
  
- 생성자와 초기화 블럭은 상속되지 않는다 멤버만 상속된다
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다
- 클래스간의 관계에서 형제 관계는 없다
- 자손클래스의 인스턴스를 생성하면 조상클래스의 멤버와 자손클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다

### 클래스 간의 관계 - 포함관계

- 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것
- 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉬움
- 단위클래스별로 코드가 작게 나뉘어 작성되어 있기 때문에 코들르 관리하는데도 수월함

### 클래스 간의 관계 결정하기

- 상속관계: ~은 ~이다
- 포함관계: ~은 ~을 가지고 있다

### 단일상속

- 자바에서는 오직 단일 상속만을 허용한다

### Object 클래스 - 모든 클래스의 조상

- Object 클래스: 모든 클래스 상속계층도의 최상위에 있는 조상클래스

---

## 오버라이딩

### 오버라이딩

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

### 오버라이딩 조건

- 자손 클래스에서 오버라이딩하는메서드는 조상 클래스의 메서드와
  - 이름이 같아야 한다
  - 매개변수가 같아야 한다
  - 반환타입이 같아야 한다
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다
- 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없다

### 오버로딩 vs. 오버라이딩

- 오버로딩: 기존에 없는 새로운 메서도를 정의하는 것
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것

### super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수
- 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 사용하는 것이 좋다.
- this와 마찬가지로 static 메서드에서는 사용할 수 없다

### super() - 조상 클래스의 생성자

- 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야한다
-> Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자,this() 또는 super(),를 호출해야한다 그렇지 않으면
컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다

---

## package와 import

### 패키지

- 클래스의 묶음
- 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리 할 수 있음


### 패키지의 선언
```
    package 패키지명;
```

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다
- 모든 클래스는 반드시 하나의 패키지에 속해야한다
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다
- 패키지명은 대소문자를 모두 허용하나, 클래스와 쉽게 구분하기 위해서 소문자로 하는 것이 원칙이다

### import문
- 클래스의 코드를 사용하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지명은 생략할 수 있다
```
import 패키지명.클래스명;
import 패키지명.*; //지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용
//실행 시 성능상의 차이는 없음
```

---

## 제어자

### 제어자
- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다
- 접근 제어자: public, protected, default, private
- 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp
- 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다

### static

- 클래스의, 공통적인
- static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않아도 사용 가능
- static 메서드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다

### final

- 마지막의, 변경될 수 없는
- 거의 모든 대상에 사용 가능
- 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면
자신을 확장하는 자손 클래스를 정의하지 못하게 된다

### abstract

- 추상의, 미완성의
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않는 추상 메서드를 선언하는데 사용
- 인스턴스 생성 불가능
- 다른 클래스가 이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩 가능

### 접근제어자

- 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
- 사용되는 곳: 클래스, 멤버변수, 메서드, 생성자
- private: 같은 클래스 내에서만 접근이 가능하다
- default: 같은 패키지 내에서만 접근이 가능하다
- protected: 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다
- public: 접근 제한이 없다
- public > protected > (default) > private
- 사용목적: 클래스의 내부에 선언된 데이터를 보호하기 위해서, 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서


### 제어자의 조합

- 메서드에 static과 abstract를 함께 사용할 수 없다
- 클래스에 abstract와 final을 동시에 사용할 수 없다
- abstract 메서드의 접근 제어자가 private일 수 없다
- 메서드에 private과 final을 같이 사용할 필요는 없다

---

## 다형성

### 다형성

- 여러 가지 형태를 가질 수 있는 능력
- 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하는 것
- 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다
- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다

### 참조 변수의 형변환

- 서로 상속관계에 있는 클래스사이에서만 가능하다
- 자손타입 -> 조상타입 : 형변환 생략 가능
- 자손타입 <- 조상타입 : 형변환 생략 불가능

### instanceof 연산자

- 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
- 왼쪽에는 참조 변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다
- 결과: boolean 값인 true나 false
- true가 반환되었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다

---

## 추상클래스

### 추상클래스

- 미완성 클래스
- 추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 갖음

### 추상메서드

- 설계만 해놓고 실제 수행될 내용은 작성하지 않은 미완성 메서드
- 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성
되었는지 알려주고, 실제 내용은 상속받는 클래스에서 구현하도록 비워둠
```
// 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다
abstract 리턴타입 메서드이름();
```

---

## 인터페이스

### 인터페이스

- 일종의 추상 클래스
- 추상 클래스처럼 추상 메서드를 갖지만 추상 클래스보다 추상화 정도가 높아서 추상 클래스와 달리 몸통만 갖춘 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다

```
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```
- 모든 멤버변수는 public, static, final이어야 하며, 이를 생략할 수 있다
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다

### 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다

### 인터페이스의 구현

```
class 클래스이름 implements 인터페이스이름{
    //인터페이스에 정의된 추상 메서드를 구현해야 한다
}
```

### 인터페이스의 장점

- 개발시간을 단축시킬 수 있다
- 표준화가 가능하다
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다
- 독립적인 프로그래밍이 가능하다

### 디폴드 메서드

- 추상 메서드의 기본적인 구현을 제공하는 메서드
- 추상 메서드가 아니기 때문에 디폴드 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다

---

## 내부 클래스

### 내부 클래스

- 클래스 내에 선언된 클래스
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있음
- 코드의 복잡성을 줄일 수 있음

### 내부 클래스 종류

- 인스턴스 클래스 (instance class)
- 스태틱 클래스 (static class)
- 지역 클래스 (local class)
- 익명 클래스 (anonymous class)