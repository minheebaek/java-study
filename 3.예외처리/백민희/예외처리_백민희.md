# 챕터 8 예외처리

컴파일 에러 : 컴파일 시에 발생하는 에러

런타임에러 : 실행 시에 발생하는 에러

논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것

에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류

예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

![image](https://github.com/minheebaek/java-study/assets/105588896/d365c79a-4a19-42fd-a0e4-8a472400e8f2)

모든 클래스의 조상은 Object클래스이므로 Exception과 Error 클래스 역시 Object 클래스의 자손들이다.

![image](https://github.com/minheebaek/java-study/assets/105588896/9de94f5d-16cf-4784-a3c2-ade8029cf2b2)

모든 예외의 최고 조상은 Exception 클래스이다

Exception 클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외

RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외

### 1 예외처리하기- try-catch문

```java
try{
	//예외가 발생할 가능성이 있는 문장들을 넣는다
} catch (Exception1 e1){
	//Exception1이 발생했을 경우 이를 처리하기 위한 문장을 적는다.
}
```

1. 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭이 올 수 있으며 이 중 발생한 예외의 종류와 일치하는 **단 한개**의 catch블럭만 수행된다.
2. try블럭, catch 블럭에 또 다른 try-catch문이 포함될 수 있다. catch블럭 내의 코드에서도 예외가 발생할 수 있기 때문이다.
3. catch블럭의 괄호 내에 선언된 변수는 catch 블럭내에서만 유효하다
4. catch블럭 내에 또 하나의 try-catch문이 포함된 경우 같은 이름의 참조변수를 사용해서는 안된다.

### 2 try-catch문에서의 흐름

1. try블럭내에서 예외가 발생한 경우
1. 발생한 예외와 일치하는 catch블럭이 있는지 확인
2. 일치하는 catch블럭을 찾게 되면 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행함. 만약 일치하는 catch 블럭을 찾지 못하면 예외는 처리하지 못한다.

### 3 예외의 발생과 catch 블럭

모든 예외 클래스는 Exception클래스의 자손이므로 catch블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해 처리된다.

printStackTrace()와 getMessage()

`printStackTrace()`

예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외메세지를 화면에 출력한다

`getMessage()`

발생한 예외클래스으 인스턴스에 저장된 메시지를 얻을 수 있다.

멀티 catch블럭

1. 여러 catch블럭을 ‘|’기호를 이용해서 하나의 catch 블럭으로 합칠 수 있게 되었다.
2. ‘|’ 기호로 연결된 예외 클래스가 조상과 자손의 관계가 있다면 컴파일 에러가 발생함→그냥 조상 클래스만 쓰는 거랑 같기 때문
3. 예외를 멀티 catch 블럭으로 처리하게 되었을 때 멀티 catch 블럭 내에서 실제로 어떤 예외가 발생한 것인지 알 수 없다.

### 4 예외 발생시키기

고의로 예외 발생

1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만듦
2. 키워드 throw를 이용해서 예외를 발생시킴

```java
Exception e = new Exception("고의로 발생시켰음")
throw e;
```

### 5 메서드에 예외 선언하기

메서드의 선언부에 키워드 throw를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주면 됨

```java
void method() throws Exception, Exception2, ... ExceptionN{
	//메서드의 내용
} 
```

이 메서드를 사용하기 위해서 어떤 예외들이 처리되어져야하는지 쉽게 알 수 있다.

예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것

### 6 finally블럭

finally블럭은 예외의 발생 여부에 상관없이 실행되어야 할 코드를 포함시킬 목적으로 사용됨

### 7 예외 되던지기

한 메서드에서 발생할 수 있는 예외가 여럿인경우 몇 개는 try-catch문을 통해서 메서드 내에서 자체적으로 처리하고 나머지는 선언부에 지정하여 호출한 메서드에서 처리하도록 한다. →양쪽 처리

방법:예외를 처리한 후에 인위적으로 다시 발생시키는 방법 사용

주의할 점:예외가 발생할 메서드에서는 try-catch문을 사용해서 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 trows에 지정해야한다.

### 8 연결된 예외

한 예외가 다른 예외를 발생시킬 수 있다.

예외 A가 예외 B를 발생시켰다면 A를 B의 ‘원인 예외’라고 한다.

`Throwable initCause(Throwable cause)`

지정한 예외를 원인 예외로 등록

`Throwable getCause()`

원인 예외를 반환